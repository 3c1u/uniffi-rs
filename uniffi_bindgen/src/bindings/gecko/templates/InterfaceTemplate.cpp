// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

{% import "macros.cpp" as cpp %}

#include "mozilla/dom/{{ obj.name()|class_name_webidl }}.h"

namespace mozilla {
namespace dom {

// Cycle collection boilerplate for our interface implementation. `mGlobal` is
// the only member that needs to be cycle-collected; if we ever add any JS
// object members or other interfaces to the class, those should be collected,
// too.
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE({{ obj.name()|class_name_webidl }}, mGlobal)
NS_IMPL_CYCLE_COLLECTING_ADDREF({{ obj.name()|class_name_webidl }})
NS_IMPL_CYCLE_COLLECTING_RELEASE({{ obj.name()|class_name_webidl }})
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION({{ obj.name()|class_name_webidl }})
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
NS_INTERFACE_MAP_END

{{ obj.name()|class_name_cpp }}::{{ obj.name()|class_name_cpp }}(
  nsIGlobalObject* aGlobal,
  int64_t aHandle
) : mGlobal(aGlobal), mHandle(aHandle) {}

{{ obj.name()|class_name_cpp }}::~{{ obj.name()|class_name_cpp }}() {
  if (mHandle != -1) {
    {{ obj.ffi_object_free().name() }}(mHandle);
    mHandle = -1;
  }
}

JSObject* {{ obj.name()|class_name_cpp }}::WrapObject(
  JSContext* aCx,
  JS::Handle<JSObject*> aGivenProto
) {
  return dom::{{ obj.name()|class_name_cpp }}_Binding::Wrap(aCx, this, aGivenProto);
}

{% for cons in obj.constructors() %}
/* static */
already_AddRefed<{{ obj.name()|class_name_cpp }}> {{ obj.name()|class_name_cpp }}::Constructor(
  {% call cpp::decl_constructor_args(cons) %}
) {
  {%- if cons.throws().is_some() %}
  RustError err = {0, nullptr};
  {% endif %}
  auto handle = {{ cons.ffi_func().name() }}(
    {%- let args = cons.arguments() %}
    {% call cpp::to_ffi_args(args) -%}
    {%- if cons.throws().is_some() %}
    {% if !args.is_empty() %},{% endif %}&err
    {% endif %}
  );
  {%- if cons.throws().is_some() %}
  if (err.mCode) {
    aRv.ThrowOperationError(err.mMessage);
    return nullptr;
  }
  {%- endif %}
  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
  auto result = MakeRefPtr<{{ obj.name()|class_name_cpp }}>(global, handle);
  return result.forget();
}
{%- endfor %}

{% for meth in obj.methods() %}
{% call cpp::decl_return_type(meth) %} {{ obj.name()|class_name_cpp }}::{{ meth.name()|fn_name_cpp }}(
  {% call cpp::decl_method_args(meth) %}
) {
  if (mHandle == -1) {
    aRv.ThrowOperationError("Can't use destroyed handle");
    {% call cpp::bail(meth) %}
  }
  {% match meth.return_type() -%}{%- when Some with (type_) -%}const {{ type_|ret_type_ffi }} loweredRetVal_ = {%- else -%}{% endmatch %}{{ meth.ffi_func().name() }}(
    mHandle
    {%- let args = meth.arguments() -%}
    {%- if !args.is_empty() %},{% endif %}
    {% call cpp::to_ffi_args(args) -%}
    {%- if meth.throws().is_some() %}
    {% if !args.is_empty() %},{% endif %}&err
    {% endif %}
  );
  {%- if meth.throws().is_some() %}
  if (err.mCode) {
    aRv.ThrowOperationError(err.mMessage);
    {% call cpp::bail(meth) %}
  }
  {%- endif %}
  {% call cpp::return(meth, "loweredRetVal_") %}
}
{% endfor %}

}  // namespace dom
}  // namespace mozilla
